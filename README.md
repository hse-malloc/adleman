# Алгоритм Адельмана для дискретного логарифмирования

## Задача дискретного логарифмирования

Пусть заданы простое число *p* и вычет *a*, показатель которого по модулю *p* равен *q*, то есть *ord<sub>p</sub> a = q* и *q | p-1*.
Пусть задан вычет *b*, удовлетворяющий сравнению

*<p align="center"> a<sup>x</sup> ≡ b (mod p) </p>*

Задача определения вычета *x (mod q)* называется задачей вычисления дискретного логарифма элемента *b* по основанию *a*.

Принято использовать обозначение

*<p align="center"> x ≡ log<sub>a</sub> b (mod q) </p>*

Сравнение разрешимо только в том случае, когда вычет *b* принадлежит множеству *__A__* = {1, *a*, *a*<sup>2</sup>, ..., *a*<sup>*q*-1</sup>}

Свойства дискретного логарифма аналогичны свойствам обычного логарифма. Так, например, если верно, что

*<p align="center"> b ≡ b<sub>1</sub><sup>α<sub>1</sub></sup> \* ... \* b<sub>k</sub><sup>α<sub>k</sub></sup> (mod p) </p>*

то выполняется равенство

*<p align="center"> log<sub>a</sub> b ≡ α<sub>1</sub> log<sub>a</sub> b<sub>1</sub> + ... + α<sub>k</sub> log<sub>a</sub> b<sub>k</sub> (mod q) </p>*

Это свойство будет использоваться дальше в методе Адельмана.

## Метод Адельмана

### Базовая идея

Допустим, что у нас есть таблица простых чисел меньших B
*<p align="center"> __F__ = {p<sub>1</sub>, p<sub>2</sub>, ..., p<sub>s</sub>}, ∀p∈F p&lt;B </p>*
мы будем называть эту таблицу факторной базой.
И допустим, что мы знаем значения логарифмов всех элементов факторной базы по основанию *a*, то есть мы знаем величины 

*<p align="center">x<sub>1</sub> ≡ log<sub>a</sub> p<sub>1</sub> (mod q)</p>* 
*<p align="center">x<sub>2</sub> ≡ log<sub>a</sub> p<sub>2</sub> (mod q)</p>* 
*<p align="center">...</p>*
*<p align="center">x<sub>s</sub> ≡ log<sub>a</sub> p<sub>s</sub> (mod q)</p>*

Тогда, если мы нашли вычет *ξ* ∈ *F<sub>q</sub><sup>\*</sup>* такой, что 
*<p align="center"> b<sup>ξ</sup> ≡ p<sub>1</sub><sup>α<sub>1</sub></sup> \* ... \* p<sub>s</sub><sup>α<sub>s</sub></sup> (mod p), </p>*
где *α<sub>i</sub>* ≥ 0 и p<sub>i</sub> ∈ *__F__* ∀ *i*=0,...,*s*,
то воспользовавшись свойством логарифма, описанным выше, получаем искомое решение поставленной задачи
*<p align="center"> log<sub>a</sub> b ≡ ξ<sup>-1</sup> \* (α<sub>1</sub> log<sub>a</sub> p<sub>1</sub> + ... + α<sub>s</sub> log<sub>a</sub> p<sub>s</sub>) (mod q) </p>*

Таким образом метод Адельмана сводится к двум последовательным шагам:
1. Построение факторной базы и нахождение логарифмов элементов этой базы
2. Подсчёт значения искомого логарифма.

### Нахождение логарифмов элементов факторной базы.

При случайном выборе *ξ* ∈ *F<sub>q</sub>* может возникнуть ситуация, когда вычет *a<sup>ξ</sup>* полностью раскладывается по элементам факторной базы, то есть
*<p align="center"> a<sup>ξ</sup> ≡ p<sub>1</sub><sup>α<sub>1</sub></sup> \* ... \* p<sub>s</sub><sup>α<sub>s</sub></sup> (mod p) </p>*
в таком случае можно утверждать, что было получено уравнение на неизвестные нам *x<sub>1</sub> ≡ log<sub>a</sub> p<sub>1</sub> (mod q), ..., x<sub>s</sub> ≡ log<sub>a</sub> p<sub>s</sub> (mod q)* :
*<p align="center"> ξ ≡ α<sub>1</sub> x<sub>1</sub> + ... + α<sub>s</sub> x<sub>s</sub> (mod q) </p>*

Задача нахождения искомых *x<sub>1</sub>, ..., x<sub>s</sub>* сводится к генерации *s* линейно независимых уравнений и нахождении их решения. Итоговая система линейных урванений будет выглядеть как:

*<p align="center"> ξ<sub>1</sub> ≡ α<sub>1</sub><sup>1</sup> x<sub>1</sub> + ... + α<sub>s</sub><sup>1</sup> x<sub>s</sub> (mod q) </p>*
*<p align="center"> ξ<sub>2</sub> ≡ α<sub>1</sub><sup>2</sup> x<sub>1</sub> + ... + α<sub>s</sub><sup>2</sup> x<sub>s</sub> (mod q) </p>*
*<p align="center"> ... </p>*
*<p align="center"> ξ<sub>s</sub> ≡ α<sub>1</sub><sup>s</sup> x<sub>1</sub> + ... + α<sub>s</sub><sup>s</sup> x<sub>s</sub> (mod q) </p>*

Или в матричном виде, как 

*<p align="center"> __ξ__ ≡ __A__ __x__</p>*

В реализации до получения искомой матрицы __A__ мы генерируем по *s* новых уравнений за один проход цикла, добавлям их к уже найденым и ищем среди них линейнонезависимые.
Для получения разложения числа *a<sup>ξ</sup>* на множители мы используем встроенную в Sage функцию `factor`, предаврительно запустив тест Миллера-Рабина.

Для упрощения работы учебного примера в настоящее время работа поддерживается только для простых *q*.

Для демонтарции работы алгоритма были сгенерированы простые числа *p* Софи Жермен порядков 2<sup>16</sup>, 2<sup>32</sup>, 2<sup>64</sup> и выбраны соответсвующие элементы *a* с мультипликативным порядком равным *q = (p-1)/2*


### Сложность алгоритма и выбор границы факторной базы.

Обозначим за *π(B)* число простых чисел, непревосходящих *B* ( *π(B) ~ B / ln B* ).

Тогда сложность составления системы линейных уравнений будет *O(π<sup>2</sup>(B) / p<sub>a</sub>)*, где *p<sub>a</sub>* - вероятность того, что *a<sup>ξ</sup>* будет разлагаться на множители по факторной базе.

Сложность решениея системы линейных уравнений будет *O(π<sup>3</sup>(B))*

Сложность нахождения значения логарифма по известным логарифмам факторной базы будет *O(π(B) / p<sub>b</sub>)*, где *p<sub>b</sub>* - вероятность того, что *b<sup>ξ</sup>* будет разлагаться на множители по факторной базе.

Итоговая сложность будет *O(π<sup>3</sup>(B) + π<sup>2</sup>(B) / p<sub>a</sub> + π(B) / p<sub>b</sub>)*.

Стоит заметить, что все величины: *π(B)*, *p<sub>a</sub>* и *p<sub>b</sub>* существенно зависят от B.

Так, например, если выбрать большое число *B*, то итоговая сложность будет упираться в решение системы линейных уравнений, т.к. *π(B)* так же возрастёт (несмотря на то, что вероятности разложения по факторной базе не будут давать большой вклад). 

Если же выбрать *B* достаточно маленьким, то и влад сложности решения системы линейных урванений будет невелик, однако тогда при случайном выборе *ξ* мы будем достаточно редко получать исходы при которых *a<sup>ξ</sup>* и *b<sup>ξ</sup>* будут разладться по факторной базе. То есть большой влкад в сложность будут играть маленькие вероятности *p<sub>a</sub>* и *p<sub>b</sub>*.

Для баланса между этими крайностями была выбрана теоретическая оценка *B ~ L(1/2 , 1/2, q)*,

где *L(1, 1/2, q) = e<sup>ln<sup>1/2</sup>q * (ln ln q)<sup>1/2</sup></sup>* - субэкспоненциальная функция
